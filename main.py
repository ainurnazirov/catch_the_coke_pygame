import pygame  # импортируем библиотеку pygame
import random  # импортируем библиотеку random

pygame.init()  # инициализируем объект класса pygame
width = 450  # в переменной хранится ширина экрана
height = 750  # в переменной хранится высота экрана
win = pygame.display.set_mode((width, height))  # создаем рабочую область
pygame.display.set_caption("Catch the Coke")  # создаем название окна
bg = pygame.image.load('Assets/bg.jpg')  # подгружаем файл с фоном
cont = pygame.image.load('Assets/container.png')  # подгружаем файл с контейнером
cont = pygame.transform.scale(cont, (70, 70))  # изменяем размер файла с контейнером
heart = pygame.image.load('Assets/heart.png')  # подгружаем файл с сердцем
heart = pygame.transform.scale(heart, (30, 30))  # изменяем размер файла с сердцем
cont_speed = 35  # объявлям переменную со скоростью контейрам
pygame.mixer.music.load("Assets/music.mp3")  # подгружаем файл с фоновой музыкой
pygame.mixer.music.set_volume(0.3)  # устанавливаем уровень громкости
pygame.mixer.music.play(-1)  # устанавливаем количество повторений на бесконечное количество


class CokeClass():  # объявляем класс CokeClass
    def __init__(self):  # объявляем конструктор класса
        self.coke_x = random.randrange(0, width - 70)  # self.coke_x - расположение бутылки по оси x. Значение
        # self.coke_x выбирается случайным образом
        self.coke_y = -70  # self.coke_y - расположение бутылки по оси y. Изначальное значение установлено на -70
        # так, чтобы бутылки не было видно
        self.coke_img = pygame.image.load('Assets/coke.png')  # подгружаем файл с изображением бутылки
        self.coke_img = pygame.transform.scale(self.coke_img, (70, 70))  # изменяем размер файла с бутылкой

    def draw(self, win, coke_speed):  # объявляем функцию для отрисовки бутылки на экране, передаем в неё переменные
        self.coke_y = self.coke_y + coke_speed  # скорость бутылки cok_speed прибавляется к расположению бутылки по
        # оси y, тем самым меняя его расположение
        win.blit(self.coke_img, (self.coke_x, self.coke_y))  # выводим на экран изборажение бытылки по координатам


def drawGame():  # объявляем функцию,отвечающей за отображение экрана игры
    win.blit(bg, (0, 0))  # отображаем фон
    win.blit(cont, (cont_x, 600))  # отображаем изображене контейнера на нужных координатах
    if lives == 3:  # если жизней 3, то:
        win.blit(heart, (400, 10))  # вывод изображения сердца на нужных координатах
        win.blit(heart, (370, 10))  # вывод изображения сердца на нужных координатах
        win.blit(heart, (340, 10))  # вывод изображения сердца на нужных координатах
    elif lives == 2:  # если жизней 2, то:
        win.blit(heart, (400, 10))  # вывод изображения сердца на нужных координатах
        win.blit(heart, (370, 10))  # вывод изображения сердца на нужных координатах
    elif lives == 1:  # если жизнь 1, то:
        win.blit(heart, (400, 10))  # вывод изображения сердца на нужных координатах

    font = pygame.font.Font('Assets/myfont.ttf', 20)  # в пеменную загружаем свой шрифт и указываем его размер
    text = font.render("Score: " + str(score), True, (255, 255, 255))  # в перменную помещаем текст, с выбранным
    # ранее шрифтом белого увета
    win.blit(text, [20, 20])  # отображаем текст на нужных координтах

    for coke in cokes:  # для каждого экземпляра объекта в списке:
        coke.draw(win, coke_speed)  # обращаемся к функции draw класса CokeClass
    pygame.display.update()  # обновляем изображение на дисплее


def drawStartMenu():  # объявляем функцию,отвечающей за отображение стартового экрана
    win.blit(bg, (0, 0))  # отображаем фон
    font = pygame.font.Font('Assets/myfont.ttf', 20)  # в пеменную загружаем свой шрифт и указываем его размер
    text = font.render("Press space to start", True, (255, 255, 255))  # в перменную помещаем текст, с выбранным
    # ранее шрифтом белого увета
    text_rect = text.get_rect(center=(width / 2, height / 2))  # центрируем прямоугольник текста
    win.blit(text, text_rect)  # высодим текст на экран
    pygame.display.update()  # обновляем дисплей


def drawMenu():  # объявляем функцию,отвечающей за отображение меню
    win.blit(bg, (0, 0))  # отображаем фон
    font = pygame.font.Font('Assets/myfont.ttf', 20)  # в пеменную загружаем свой шрифт и указываем его размер
    text = font.render("Final score: " + str(score), True, (255, 255, 255))  # в перменную помещаем текст, с выбранным
    # ранее шрифтом белого увета
    text2 = font.render("Press space to continue", True, (255, 255, 255))  # в перменную помещаем текст, с выбранным
    # ранее шрифтом белого увета
    text_rect = text.get_rect(center=(width / 2, height / 2 - 20))  # центрируем прямоугольник текста со смещением вверх
    text_rect2 = text2.get_rect(center=(width / 2, height / 2 + 20))  # центрируем прямоугольник текста со смещением
    # вниз
    win.blit(text, text_rect)  # высодим текст на экран
    win.blit(text2, text_rect2)  # высодим текст на экран
    pygame.display.update()  # обновляем дисплей


run = True  # объявляем переменную, отвечающую за повторение цикла
start = True  # объявляем переменную, отвечающую за вывод стартового экрана
lives = 3  # в переменной хранится количество жизней, по умолчанию 3
score = 0  # в переменной хранится количество очков, набранных за игру, по умолчанию 0
cont_x = (width - 70) / 2  # объявляем переменную с местоположением контейнера по оси x
cokes = []  # создается список, хранящие экземпляры класс CokeClass
coke_speed = 20  # в переменной хранится скорость падения бутылки, по умолчанию 20
level = 9  # в переменной хранится количество очков, после которого увеличится скорость падения бутылок, по умолчанию 9
while run:  # объявляем цикл while
    pygame.time.delay(100)  # приостанавливает выполнение программы на некоторое время, в миллисекундах

    while start:  # цикл, отвечающий за отображение стартового экрана
        for event in pygame.event.get():  # в pygame.event.get() сохраняются произошедшие события
            if event.type == pygame.QUIT:  # если тип события - выход, то:
                start = False  # переменная принимает значение False и цикл прерывается
                run = False  # переменная run ставновится равна False и цикл прерывается
            elif event.type == pygame.KEYDOWN:  # если тип событие - нажатие на клавишу, то
                if event.key == pygame.K_SPACE:  # если нажатае клавишу - пробел, то
                    start = False  # переменная принимает значение False и цикл прерывается
        drawStartMenu()  # вызов функции, отвечающей за отображение стартового экрана

    if lives != 0:  # если количество жизней больше 0, то:
        for event in pygame.event.get():  # в pygame.event.get() сохраняются произошедшие события
            if event.type == pygame.QUIT:  # если тип события - выход, то:
                run = False  # переменная run ставновится равна False и цикл прерывается

        for coke in cokes:  # для каждого экземпляра класса CokeClass из списка cokes
            if coke.coke_y > 550 and -35 < cont_x - coke.coke_x < 35:  # если координата бутылки по оси y больше 550
                # (зависит от расположения контейнера по той же оси) и разница между координатами контейнера и
                # бутылки по оси x больше -35 и меньше 35 (потому что бутылка может быть как правее, так и левее), то:
                score += 1  # количество очков увеличивается на 1
                cokes.pop(cokes.index(coke))  # бутылка по индексу удаляется из списка бутылок
            elif coke.coke_y > height:  # если бутылка ниже конца экрана по y (вышла за пределы экрана), то:
                cokes.pop(cokes.index(coke))  # бутылка по индексу удаляется из списка бутылок
                lives -= 1  # у игрока отнимается одна жизнь

        if score > level:  # если количество набранных очков больше установленного барьера, то:
            level += 10  # барьер увеличивается на 10
            coke_speed += 10  # скорость падения бутылок увеличивается на 10

        if len(cokes) < 1:  # если список бутылок короче 1, то:
            cokes.append(CokeClass())  # создается экземпляр класс CokeClass
        keys = pygame.key.get_pressed()  # в список сохраняем нажатые клавиши

        if keys[pygame.K_LEFT] and cont_x > 0:  # если нажата клавиша влево и координата контейнера по x больше 0, то:
            cont_x -= cont_speed  # от координаты отнимается значение, равное скорости движения контейнера
        if keys[pygame.K_RIGHT] and cont_x < width - 70:  # если нажата клавиша вправо и координата контейнера по x
            # меньше ширины экрана - 70, то:
            cont_x += cont_speed  # к координате прибавляется значение, равное скорости движения контейнера

        drawGame()  # вызов функции, отвечающей за отображение экрана игры

    else:  # иначе
        for event in pygame.event.get():  # в pygame.event.get() сохраняются произошедшие события
            if event.type == pygame.QUIT:  # если тип события - выход, то:
                run = False  # переменная run ставновится равна False и цикл прерывается
            elif event.type == pygame.KEYDOWN:  # если тип событие - нажатие на клавишу, то
                if event.key == pygame.K_SPACE:  # если нажатае клавишу - пробел, то
                    cont_x = (width - 70) / 2  # координата контейнера по оси x становится равна значению по умолчанию
                    cokes = []  # список, хранящие экземпляры класс CokeClass, очищается
                    score = 0  # количество очков становится равным 0
                    coke_speed = 20  # скорость падения бутылки становится равна 20
                    lives = 3  # количесто жизней становится равным 3
                    level = 9  # барьер увеличение скорости становится равен 9

        drawMenu()  # вызов функции, отвечающей за отображение меню

pygame.quit()  # выход из программы
